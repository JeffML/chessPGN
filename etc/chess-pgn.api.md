## API Report File for "@chess-pgn/chess-pgn"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export const BISHOP = "b";

// @public (undocumented)
export const BITS: Record<string, number>;

// @public (undocumented)
export const BLACK = "b";

// @public (undocumented)
export class ChessPGN implements IChessGame {
    constructor(fen?: string, { skipValidation }?: {
        skipValidation?: boolean | undefined;
    });
    // (undocumented)
    ascii(): string;
    // (undocumented)
    attackers(square: Square, attackedBy?: Color): Square[];
    // (undocumented)
    board(): ({
        square: Square;
        type: PieceSymbol;
        color: Color;
    } | null)[][];
    // (undocumented)
    clear({ preserveHeaders }?: {
        preserveHeaders?: boolean | undefined;
    }): void;
    // @deprecated (undocumented)
    deleteComment(): string | undefined;
    // @deprecated (undocumented)
    deleteComments(): {
        fen: string;
        comment: string;
    }[];
    // (undocumented)
    fen({ forceEnpassantSquare, }?: {
        forceEnpassantSquare?: boolean;
    }): string;
    // (undocumented)
    findPiece(piece: Piece): Square[];
    // (undocumented)
    get(square: Square): Piece | undefined;
    // (undocumented)
    getCastlingRights(color: Color): {
        [KING]: boolean;
        [QUEEN]: boolean;
    };
    // (undocumented)
    getComment(): string | undefined;
    // (undocumented)
    getComments(): {
        fen: string;
        comment?: string;
        suffixAnnotation?: string;
    }[];
    // (undocumented)
    getHeaders(): Record<string, string>;
    // Warning: (ae-forgotten-export) The symbol "Suffix" needs to be exported by the entry point chessPGN.d.ts
    getSuffixAnnotation(fen?: string): Suffix | undefined;
    // (undocumented)
    hash(): string;
    // @deprecated (undocumented)
    header(...args: string[]): Record<string, string | null>;
    // (undocumented)
    history(): string[];
    // (undocumented)
    history({ verbose }: {
        verbose: true;
    }): Move[];
    // (undocumented)
    history({ verbose }: {
        verbose: false;
    }): string[];
    // (undocumented)
    history({ verbose }: {
        verbose: boolean;
    }): string[] | Move[];
    // (undocumented)
    inCheck(): boolean;
    // (undocumented)
    isAttacked(square: Square, attackedBy: Color): boolean;
    // (undocumented)
    isCheck(): boolean;
    // (undocumented)
    isCheckmate(): boolean;
    // (undocumented)
    isDraw(): boolean;
    // (undocumented)
    isDrawByFiftyMoves(): boolean;
    // (undocumented)
    isGameOver(): boolean;
    // (undocumented)
    isInsufficientMaterial(): boolean;
    // (undocumented)
    isPromotion({ from, to }: {
        from: Square;
        to: Square;
    }): boolean;
    // (undocumented)
    isStalemate(): boolean;
    // (undocumented)
    isThreefoldRepetition(): boolean;
    // (undocumented)
    load(fen: string, { skipValidation, preserveHeaders }?: {
        skipValidation?: boolean | undefined;
        preserveHeaders?: boolean | undefined;
    }): void;
    // (undocumented)
    loadPgn(pgn: string, { strict, newlineChar, }?: {
        strict?: boolean;
        newlineChar?: string;
    }): void;
    // (undocumented)
    move(move: string | {
        from: string;
        to: string;
        promotion?: string;
    } | null, { strict }?: {
        strict?: boolean;
    }): Move;
    // (undocumented)
    moveNumber(): number;
    // (undocumented)
    moves(): string[];
    // (undocumented)
    moves({ square }: {
        square: Square;
    }): string[];
    // (undocumented)
    moves({ piece }: {
        piece: PieceSymbol;
    }): string[];
    // (undocumented)
    moves({ square, piece }: {
        square: Square;
        piece: PieceSymbol;
    }): string[];
    // (undocumented)
    moves({ verbose, square }: {
        verbose: true;
        square?: Square;
    }): Move[];
    // (undocumented)
    moves({ verbose, square }: {
        verbose: false;
        square?: Square;
    }): string[];
    // (undocumented)
    moves({ verbose, square, }: {
        verbose?: boolean;
        square?: Square;
    }): string[] | Move[];
    // (undocumented)
    moves({ verbose, piece }: {
        verbose: true;
        piece?: PieceSymbol;
    }): Move[];
    // (undocumented)
    moves({ verbose, piece }: {
        verbose: false;
        piece?: PieceSymbol;
    }): string[];
    // (undocumented)
    moves({ verbose, piece, }: {
        verbose?: boolean;
        piece?: PieceSymbol;
    }): string[] | Move[];
    // (undocumented)
    moves({ verbose, square, piece, }: {
        verbose: true;
        square?: Square;
        piece?: PieceSymbol;
    }): Move[];
    // (undocumented)
    moves({ verbose, square, piece, }: {
        verbose: false;
        square?: Square;
        piece?: PieceSymbol;
    }): string[];
    // (undocumented)
    moves({ verbose, square, piece, }: {
        verbose?: boolean;
        square?: Square;
        piece?: PieceSymbol;
    }): string[] | Move[];
    // (undocumented)
    moves({ square, piece }: {
        square?: Square;
        piece?: PieceSymbol;
    }): Move[];
    // (undocumented)
    perft(depth: number): number;
    // (undocumented)
    pgn({ newline, maxWidth, }?: {
        newline?: string;
        maxWidth?: number;
    }): string;
    // (undocumented)
    put({ type, color }: {
        type: PieceSymbol;
        color: Color;
    }, square: Square): boolean;
    // (undocumented)
    remove(square: Square): Piece | undefined;
    // (undocumented)
    removeComment(): string | undefined;
    // (undocumented)
    removeComments(): {
        fen: string;
        comment: string;
    }[];
    // (undocumented)
    removeHeader(key: string): boolean;
    removeSuffixAnnotation(fen?: string): Suffix | undefined;
    // (undocumented)
    reset(preserveHeaders?: boolean): void;
    // (undocumented)
    setCastlingRights(color: Color, rights: Partial<Record<typeof KING | typeof QUEEN, boolean>>): boolean;
    // (undocumented)
    setComment(comment: string): void;
    // (undocumented)
    setHeader(key: string, value: string): Record<string, string>;
    setSuffixAnnotation(suffix: Suffix, fen?: string): void;
    // (undocumented)
    setTurn(color: Color): boolean;
    // (undocumented)
    squareColor(square: Square): 'light' | 'dark' | null;
    // (undocumented)
    turn(): Color;
    // (undocumented)
    undo(): Move | null;
}

// @public (undocumented)
export type Color = 'w' | 'b';

// @public
export interface Cursor {
    // (undocumented)
    [Symbol.asyncIterator]?(): AsyncIterableIterator<IChessGame>;
    // (undocumented)
    before?(): IChessGame | null;
    // (undocumented)
    errors: Array<{
        index: number;
        error: Error;
    }>;
    // (undocumented)
    findNext?(predicate: (headers: Record<string, string>) => boolean): IChessGame | null;
    // (undocumented)
    hasBefore?(): boolean;
    // (undocumented)
    hasNext(): boolean;
    // (undocumented)
    next(): IChessGame | null;
    // (undocumented)
    position: number;
    // (undocumented)
    reset?(): void;
    // (undocumented)
    seek?(index: number): boolean;
    // (undocumented)
    totalGames?: number;
}

// @public
export class CursorImpl implements Cursor {
    // (undocumented)
    [Symbol.asyncIterator](): AsyncIterableIterator<IChessGame>;
    // Warning: (ae-forgotten-export) The symbol "GameIndex" needs to be exported by the entry point chessPGN.d.ts
    constructor(pgn: string, indices: GameIndex[], options?: CursorOptions);
    // (undocumented)
    before(): IChessGame | null;
    // (undocumented)
    errors: Array<{
        index: number;
        error: Error;
    }>;
    // (undocumented)
    findNext(predicate: (headers: Record<string, string>) => boolean): IChessGame | null;
    // (undocumented)
    hasBefore(): boolean;
    // (undocumented)
    hasNext(): boolean;
    // (undocumented)
    next(): IChessGame | null;
    pgn({ newline, maxWidth, }?: {
        newline?: string;
        maxWidth?: number;
    }): string;
    // (undocumented)
    get position(): number;
    // (undocumented)
    reset(): void;
    // (undocumented)
    seek(index: number): boolean;
    terminate(): Promise<void>;
    // (undocumented)
    totalGames?: number;
}

// @public
export interface CursorOptions {
    // (undocumented)
    cacheSize?: number;
    // (undocumented)
    includeMetadata?: boolean;
    // (undocumented)
    lazyParse?: boolean;
    // (undocumented)
    length?: number;
    // (undocumented)
    onError?: (error: Error, gameIndex: number) => void;
    // (undocumented)
    prefetch?: number;
    // (undocumented)
    start?: number;
    // (undocumented)
    strict?: boolean;
    // (undocumented)
    workerBatchSize?: number;
    // (undocumented)
    workers?: boolean | number;
}

// @public
export const DEFAULT_POSITION = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

// @public (undocumented)
export const FLAGS: Record<string, string>;

// @public
export class Game implements IChessGame {
    // Warning: (ae-forgotten-export) The symbol "Node_2" needs to be exported by the entry point chessPGN.d.ts
    constructor(headers?: Record<string, string>, root?: Node_2);
    // (undocumented)
    ascii(): string;
    // (undocumented)
    _attacked(color: Color, square: number): boolean;
    // (undocumented)
    _attacked(color: Color, square: number, verbose: false): boolean;
    // (undocumented)
    _attacked(color: Color, square: number, verbose: true): Square[];
    // (undocumented)
    attackers(square: Square, attackedBy?: Color): Square[];
    // (undocumented)
    board(): ({
        square: Square;
        type: PieceSymbol;
        color: Color;
    } | null)[][];
    // (undocumented)
    get _board(): Piece[];
    // (undocumented)
    _castling: Record<Color, number>;
    // (undocumented)
    _castlingKey(): bigint;
    clear(preserveHeaders?: boolean): void;
    // (undocumented)
    _clear(sq: number): void;
    // (undocumented)
    _comments: Record<string, string>;
    // (undocumented)
    _computeHash(): bigint;
    // (undocumented)
    _decPositionCount(hash: bigint): void;
    // (undocumented)
    _epKey(): bigint;
    // (undocumented)
    _epSquare: number;
    fen({ forceEnpassantSquare, }?: {
        forceEnpassantSquare?: boolean;
    }): string;
    // (undocumented)
    _fenEpSquare: number;
    // (undocumented)
    findPiece(piece: Piece): Square[];
    // (undocumented)
    get(square: Square): Piece | undefined;
    // (undocumented)
    getComment(fen?: string): string | undefined;
    // (undocumented)
    getComments(): {
        fen: string;
        comment?: string;
        suffixAnnotation?: string;
    }[];
    // (undocumented)
    getHeaders(): Record<string, string>;
    // (undocumented)
    getSuffixAnnotation(fen?: string): Suffix | undefined;
    // (undocumented)
    _halfMoves: number;
    // (undocumented)
    _hash: bigint;
    // @deprecated (undocumented)
    header(...args: string[]): Record<string, string | null>;
    // (undocumented)
    _header: Record<string, string | null>;
    // (undocumented)
    history(): string[];
    // (undocumented)
    history({ verbose }: {
        verbose: true;
    }): Move[];
    // (undocumented)
    history({ verbose }: {
        verbose: false;
    }): string[];
    // (undocumented)
    history({ verbose }: {
        verbose: boolean;
    }): string[] | Move[];
    // Warning: (ae-forgotten-export) The symbol "History_2" needs to be exported by the entry point chessPGN.d.ts
    //
    // (undocumented)
    _history: History_2[];
    // (undocumented)
    inCheck(): boolean;
    // (undocumented)
    _incPositionCount(): void;
    // @internal
    static _inferPieceType(san: string): PieceSymbol | undefined;
    // (undocumented)
    isAttacked(square: Square, attackedBy: Color): boolean;
    // (undocumented)
    isCheck(): boolean;
    // (undocumented)
    isCheckmate(): boolean;
    // (undocumented)
    isCheckmate(legalMoves: InternalMove[]): boolean;
    // (undocumented)
    isDraw(): boolean;
    // (undocumented)
    isDraw(legalMoves: InternalMove[]): boolean;
    // (undocumented)
    isDrawByFiftyMoves(): boolean;
    // (undocumented)
    isGameOver(): boolean;
    // (undocumented)
    isGameOver(legalMoves: InternalMove[]): boolean;
    // (undocumented)
    isInsufficientMaterial(): boolean;
    // (undocumented)
    _isKingAttacked(color: Color): boolean;
    // (undocumented)
    isStalemate(): boolean;
    // (undocumented)
    isStalemate(legalMoves: InternalMove[]): boolean;
    // (undocumented)
    isThreefoldRepetition(): boolean;
    // (undocumented)
    _kings: Record<Color, number>;
    load(fen: string, { skipValidation }?: {
        skipValidation?: boolean;
    }): void;
    // (undocumented)
    _makeMove(move: InternalMove): void;
    move(move: string | {
        from: string;
        to: string;
        promotion?: string;
    } | null, { strict }?: {
        strict?: boolean;
    }): Move;
    // @internal
    _moveFromSan(move: string, strict?: boolean): InternalMove | null;
    // (undocumented)
    _moveNumber: number;
    // (undocumented)
    _movePiece(from: number, to: number): void;
    moves(): string[];
    // (undocumented)
    moves({ square }: {
        square: Square;
    }): string[];
    // (undocumented)
    moves({ piece }: {
        piece: PieceSymbol;
    }): string[];
    // (undocumented)
    moves({ square, piece }: {
        square: Square;
        piece: PieceSymbol;
    }): string[];
    // (undocumented)
    moves({ verbose, square }: {
        verbose: true;
        square?: Square;
    }): Move[];
    // (undocumented)
    moves({ verbose, square }: {
        verbose: false;
        square?: Square;
    }): string[];
    // (undocumented)
    moves({ verbose, square, }: {
        verbose?: boolean;
        square?: Square;
    }): string[] | Move[];
    // (undocumented)
    moves({ verbose, piece }: {
        verbose: true;
        piece?: PieceSymbol;
    }): Move[];
    // (undocumented)
    moves({ verbose, piece }: {
        verbose: false;
        piece?: PieceSymbol;
    }): string[];
    // (undocumented)
    moves({ verbose, piece, }: {
        verbose?: boolean;
        piece?: PieceSymbol;
    }): string[] | Move[];
    // (undocumented)
    moves({ verbose, square, piece, }: {
        verbose: true;
        square?: Square;
        piece?: PieceSymbol;
    }): Move[];
    // (undocumented)
    moves({ verbose, square, piece, }: {
        verbose: false;
        square?: Square;
        piece?: PieceSymbol;
    }): string[];
    // (undocumented)
    moves({ verbose, square, piece, }: {
        verbose?: boolean;
        square?: Square;
        piece?: PieceSymbol;
    }): string[] | Move[];
    // (undocumented)
    moves({ square, piece }: {
        square?: Square;
        piece?: PieceSymbol;
    }): Move[];
    // (undocumented)
    _moves({ legal, piece, square, }?: {
        legal?: boolean;
        piece?: PieceSymbol;
        square?: Square;
    }): InternalMove[];
    // @internal
    _moveToSan(move: InternalMove, moves: InternalMove[]): string;
    pgn({ newline, maxWidth, }?: {
        newline?: string;
        maxWidth?: number;
    }): string;
    // (undocumented)
    _pieceKey(i: number): bigint;
    // Warning: (ae-forgotten-export) The symbol "Position" needs to be exported by the entry point chessPGN.d.ts
    //
    // (undocumented)
    _position: Position;
    // (undocumented)
    _positionCount: Map<bigint, number>;
    _pruneComments(): void;
    // (undocumented)
    _push(move: InternalMove): void;
    // (undocumented)
    removeComment(fen?: string): string | undefined;
    // (undocumented)
    removeComments(): {
        fen: string;
        comment: string;
    }[];
    // (undocumented)
    removeHeader(key: string): boolean;
    // (undocumented)
    removeSuffixAnnotation(fen?: string): Suffix | undefined;
    reset(preserveHeaders?: boolean): void;
    // (undocumented)
    _set(sq: number, piece: Piece): void;
    // (undocumented)
    setComment(comment: string, fen?: string): void;
    // @internal
    _setCommentRaw(comment: string, fen?: string): void;
    // (undocumented)
    setHeader(key: string, value: string): Record<string, string>;
    // (undocumented)
    setSuffixAnnotation(suffix: Suffix, fen?: string): void;
    // @internal
    static _strippedSan(move: string): string;
    // (undocumented)
    _suffixes: Record<string, Suffix>;
    // (undocumented)
    _turn: Color;
    undo(): Move | null;
    // (undocumented)
    _undoMove(): InternalMove | null;
    // (undocumented)
    _updateCastlingRights(): void;
    // (undocumented)
    _updateEnPassantSquare(): void;
}

// @public
export interface IChessGame {
    ascii(): string;
    attackers(square: Square, attackedBy?: Color): Square[];
    board(): ({
        square: Square;
        type: PieceSymbol;
        color: Color;
    } | null)[][];
    fen(options?: {
        forceEnpassantSquare?: boolean;
    }): string;
    findPiece(piece: Piece): Square[];
    get(square: Square): Piece | undefined;
    getComment(fen?: string): string | undefined;
    getComments(): {
        fen: string;
        comment?: string;
        suffixAnnotation?: string;
    }[];
    getHeaders(): Record<string, string>;
    getSuffixAnnotation(fen?: string): Suffix | undefined;
    history(): string[];
    // (undocumented)
    history(options: {
        verbose: true;
    }): Move[];
    // (undocumented)
    history(options: {
        verbose: false;
    }): string[];
    // (undocumented)
    history(options: {
        verbose: boolean;
    }): string[] | Move[];
    inCheck(): boolean;
    isAttacked(square: Square, attackedBy: Color): boolean;
    isCheck(): boolean;
    isCheckmate(): boolean;
    isDraw(): boolean;
    isDrawByFiftyMoves(): boolean;
    isGameOver(): boolean;
    isInsufficientMaterial(): boolean;
    isStalemate(): boolean;
    isThreefoldRepetition(): boolean;
    load(fen: string, options?: {
        skipValidation?: boolean;
        preserveHeaders?: boolean;
    }): void;
    move(move: string | {
        from: string;
        to: string;
        promotion?: string;
    } | null, options?: {
        strict?: boolean;
    }): Move;
    pgn(options?: {
        newline?: string;
        maxWidth?: number;
    }): string;
    removeComment(fen?: string): string | undefined;
    removeComments(): {
        fen: string;
        comment: string;
    }[];
    removeHeader(key: string): boolean;
    removeSuffixAnnotation(fen?: string): Suffix | undefined;
    reset(preserveHeaders?: boolean): void;
    setComment(comment: string, fen?: string): void;
    setHeader(key: string, value: string): Record<string, string>;
    setSuffixAnnotation(suffix: Suffix, fen?: string): void;
    undo(): Move | null;
}

// @public
export function indexPgnGames(pgn: string): GameIndex[];

// @public (undocumented)
export type InternalMove = {
    color: Color;
    from: number;
    to: number;
    piece: PieceSymbol;
    captured?: PieceSymbol;
    promotion?: PieceSymbol;
    flags: number;
};

// @public (undocumented)
export const KING = "k";

// @public (undocumented)
export const KNIGHT = "n";

// @public
export class Move {
    constructor(internal: InternalMove, san: string, before: string, after: string);
    // (undocumented)
    after: string;
    // (undocumented)
    before: string;
    // (undocumented)
    captured?: PieceSymbol;
    // (undocumented)
    color: Color;
    // @deprecated (undocumented)
    flags: string;
    // (undocumented)
    from: Square;
    // (undocumented)
    isBigPawn(): boolean;
    // (undocumented)
    isCapture(): boolean;
    // (undocumented)
    isEnPassant(): boolean;
    // (undocumented)
    isKingsideCastle(): boolean;
    // (undocumented)
    isNullMove(): boolean;
    // (undocumented)
    isPromotion(): boolean;
    // (undocumented)
    isQueensideCastle(): boolean;
    // (undocumented)
    lan: string;
    // (undocumented)
    piece: PieceSymbol;
    // (undocumented)
    promotion?: PieceSymbol;
    // (undocumented)
    san: string;
    // (undocumented)
    to: Square;
}

// @public (undocumented)
export const PAWN = "p";

// @public (undocumented)
export type Piece = {
    color: Color;
    type: PieceSymbol;
};

// @public (undocumented)
export type PieceSymbol = 'p' | 'n' | 'b' | 'r' | 'q' | 'k';

// @public (undocumented)
export const QUEEN = "q";

// @public (undocumented)
export const ROOK = "r";

// @public (undocumented)
export const SEVEN_TAG_ROSTER: Record<string, string>;

// @public (undocumented)
export type Square = 'a8' | 'b8' | 'c8' | 'd8' | 'e8' | 'f8' | 'g8' | 'h8' | 'a7' | 'b7' | 'c7' | 'd7' | 'e7' | 'f7' | 'g7' | 'h7' | 'a6' | 'b6' | 'c6' | 'd6' | 'e6' | 'f6' | 'g6' | 'h6' | 'a5' | 'b5' | 'c5' | 'd5' | 'e5' | 'f5' | 'g5' | 'h5' | 'a4' | 'b4' | 'c4' | 'd4' | 'e4' | 'f4' | 'g4' | 'h4' | 'a3' | 'b3' | 'c3' | 'd3' | 'e3' | 'f3' | 'g3' | 'h3' | 'a2' | 'b2' | 'c2' | 'd2' | 'e2' | 'f2' | 'g2' | 'h2' | 'a1' | 'b1' | 'c1' | 'd1' | 'e1' | 'f1' | 'g1' | 'h1';

// @public (undocumented)
export const SQUARES: Square[];

// @public (undocumented)
export function validateFen(fen: string): {
    ok: boolean;
    error?: string;
};

// @public (undocumented)
export const WHITE = "w";

// @public
export function xoroshiro128(state: bigint): () => bigint;

// (No @packageDocumentation comment for this package)

```
